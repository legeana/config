#!/usr/bin/python3

import os
from os.path import abspath, join
from pprint import pprint, pformat
import subprocess
import tempfile
import urllib.parse
import urllib.request

from pika_ssh_sync import gpgutil
from pika_ssh_sync import keysutil


KEYBASETOKEN = 'auto-keybase-pgp'
GNUPGTOKEN = 'auto-gnupg-'
GNUPGULTIMATE = 'auto-gnupg-ultimate'
GITHUBTOKEN = 'auto-github-'
GITLABTOKEN = 'auto-gitlab-'


def filter_keys(f, add=None):
  authorized_keys = keysutil.AuthorizedKeys.load()
  # remove old entries first as f will match add[...]
  authorized_keys.filter(f)
  if add is not None:
    authorized_keys.extend(add)
  authorized_keys.save()


def make_ssh_keys(key, token, ssh_exporter):
  for subkey in key.subkeys:
    if 'a' not in subkey.capabilities:
      continue
    if subkey.bad():
      continue
    sshkey = ssh_exporter(subkey.fingerprint)
    yield '{sshkey} {token} {uids} {fp}\n'.format(
        sshkey=sshkey,
        token=token,
        uids=', '.join(map(lambda uid: uid.name, key.uids)),
        fp=subkey.fingerprint)


def export_keybase():
  with tempfile.TemporaryDirectory() as tmpdir:
    gpg = gpgutil.GPG(gnupghome=tmpdir)
    pubkey = subprocess.check_output(['keybase', 'pgp', 'export'])
    gpg.import_keys(pubkey)
    sshkeys = []
    for key in gpg.list_keys():
      sshkeys.extend(make_ssh_keys(key, KEYBASETOKEN, gpg.export_ssh_key))
    filter_keys(f=keysutil.is_not_token(KEYBASETOKEN), add=sshkeys)


def export_gpg(fingerprint):
  token = GNUPGTOKEN + fingerprint
  gpg = gpgutil.GPG()
  sshkeys = []
  key = gpg.list_key(fingerprint)
  if key:
    sshkeys.extend(make_ssh_keys(key, token, gpg.export_ssh_key))
  filter_keys(f=keysutil.is_not_token(token), add=sshkeys)


def export_ultimate():
  gpg = gpgutil.GPG()
  sshkeys = []
  for key in gpg.list_keys():
    if 'u' in key.owner_trust:
      sshkeys.extend(make_ssh_keys(key, GNUPGULTIMATE, gpg.export_ssh_key))
  filter_keys(f=keysutil.is_not_token(GNUPGULTIMATE), add=sshkeys)


def get_github_user() -> str:
  import git  # type: ignore
  config = git.Repo(os.path.join(os.getenv('HOME'), 'config'))
  config_origin = config.remote('origin')
  for url in config.remote('origin').urls:
    purl = urllib.parse.urlparse(url)
    if purl.netloc != 'github.com':
      continue
    components = purl.path.split('/', 2)
    if len(components) >= 2:
      if components[0] != '':
        continue
      return components[1]
  raise RuntimeError('Unable to identify github user, '
                     'do you have ~/config installed?')


def export_keys_api(url: str, token: str) -> None:
  with urllib.request.urlopen(url, timeout=30) as f:
    keys = f.read().decode('utf8').split('\n')
  sshkeys = [f'{key} {token}' for key in keys]
  filter_keys(f=keysutil.is_not_token(token), add=sshkeys)


def export_github():
  user = get_github_user()
  token = f'{GITHUBTOKEN}{user}@github.com'
  export_keys_api(url=f'https://github.com/{user}.keys', token=token)


def export_gitlab():
  # FIXME: This is unsafe for many people, a config file should be used instead.
  # Assume that github and gitlab users are the same.
  user = get_github_user()
  token = f'{GITLABTOKEN}{user}@gitlab.com'
  export_keys_api(url=f'https://gitlab.com/{user}.keys', token=token)


def try_do(f, *args, **kwargs):
  try:
    f(*args, **kwargs)
  except Exception as e:
    print('Unable to do', f.__name__)
    print(e)


def main():
  try_do(export_keybase)
  try_do(export_ultimate)
  try_do(export_github)
  try_do(export_gitlab)


if __name__ == '__main__':
  main()
