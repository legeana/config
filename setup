#!/usr/bin/env python3

import abc
import argparse
import asyncio
import dataclasses
import os
import pathlib
import shlex
import shutil
import subprocess
import sys
from typing import Container, List

SELF = pathlib.Path(__file__).absolute()
ROOT = SELF.parent
OVERLAYS = ROOT / 'overlay.d'
INSTALL = ROOT / '.install'
BASE = ROOT / 'base'


def log(*args, **kwargs):
  print(*args, **kwargs, file=sys.stderr)


async def run(*args, **kwargs) -> subprocess.CompletedProcess:
  process = await asyncio.create_subprocess_exec(*args, **kwargs)
  stdout, stderr = await process.communicate()
  retcode = await process.wait()
  return subprocess.CompletedProcess(args, retcode, stdout, stderr)


async def check_output(*args, **kwargs) -> bytes:
  kwargs['stdout'] = subprocess.PIPE
  kwargs['stderr'] = subprocess.STDOUT
  ret = await run(*args, **kwargs)
  ret.check_returncode()
  return ret.stdout


async def update(plugin: pathlib.Path) -> bool:
  gitdir = plugin / '.git'
  if not gitdir.is_dir():
    return False
  ref = gitdir / 'refs' / 'heads' / 'master'
  with open(ref) as f:
    old_ref = f.read()
  args = ['git', '-C', str(plugin), 'pull', '--ff-only']
  try:
    output = await check_output(*args)
    log(f'Updated {str(plugin)}: {output.decode().strip()}')
  except subprocess.CalledProcessError as e:
    # TODO use shlex.join(), python-3.8+
    command = ' '.join(shlex.quote(arg) for arg in args)
    sys.exit(f'Failed to update {str(plugin)}, manual intervention is required!\n'
             f'$ {command}\n'
             f'{e.stdout.decode().strip()}')
  with open(ref) as f:
    new_ref = f.read()
  if old_ref != new_ref:
    return True


async def update_all() -> bool:
  log('Updating...')
  updates = [update(ROOT)] + [
      update(overlay) for overlay in OVERLAYS.iterdir()
      if overlay.is_dir()
  ]
  update_results = await asyncio.gather(*updates, return_exceptions=False)
  log()
  assert len(updates) == len(update_results)
  for res in update_results:
    if isinstance(res, BaseException):
      raise res
  return update_results[0]


class InstalledDatabase:

  def __init__(self):
    self._entries = []

  @classmethod
  def load_from(cls, path):
    inst = cls()
    try:
      with open(path) as f:
        for line in f:
          inst._add_line(line.strip())
    except FileNotFoundError:
      pass
    return inst

  def _add_line(self, line):
    self.add(line)

  def write(self, fp):
    for item in sorted(self._entries):
      self.write_line(fp, item)

  def write_file(self, path):
    with open(path, 'w') as f:
      self.write(f)

  @classmethod
  def write_item(cls, fp, item) -> None:
    fp.write(str(item))
    fp.write('\n')

  def add(self, item: pathlib.Path) -> None:
    self._entries.append(str(item))

  def clear(self) -> None:
    self._entries.clear()

  def __contains__(self, item):
    return str(item) in self._entries

  def __iter__(self):
    return map(pathlib.Path, self._entries)

  def __reversed__(self):
    return map(pathlib.Path, reversed(self._entries))

  def __bool__(self):
    return bool(self._entries)


class SyncInstalledDatabase(InstalledDatabase):

  def __init__(self, path: pathlib.Path):
    super().__init__()
    self._path = path

  def add(self, item: pathlib.Path) -> None:
    if item in self:
      return
    mode = 'a' if self else 'w'
    super().add(item)
    with open(self._path, mode) as f:
      self.write_item(f, item)


class Entry(abc.ABC):

  @abc.abstractmethod
  def __call__(self, db: InstalledDatabase) -> None:
    pass


@dataclasses.dataclass
class FileEntry(Entry):

  src: str
  dst: str


class SymlinkEntry(FileEntry):

  def __call__(self, db: InstalledDatabase) -> None:
    if self.dst.exists():
      if not self.dst.is_symlink():
        log(f'Symlink: unable to overwrite {str(self.dst)}')
        return
      self.dst.unlink()
    self.dst.parent.mkdir(parents=True, exist_ok=True)
    self.dst.symlink_to(self.src)
    db.add(self.dst)
    log(f'{str(self.src)} -> {str(self.dst)}')


class CopyEntry(FileEntry):

  def __call__(self, db: InstalledDatabase) -> None:
    if self.dst.exists():
      log(f'Copy: skipping already existing {str(self.dst)}')
      return
    self.dst.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(self.src, self.dst)
    # do not record this file in the deletion database to prevent data loss
    log(f'{str(self.src)} -> {str(self.dst)}')


class ParserError(Exception):
  pass


@dataclasses.dataclass
class Parser(abc.ABC):

  root: pathlib.Path
  prefix: pathlib.Path

  @property
  @abc.abstractmethod
  def supported_commands(self) -> Container[str]:
    return []

  def check_supported(self, command: str) -> None:
    if command not in self.supported_commands:
      raise ParserError(f'{command} is not supported by {type(self)}')

  @abc.abstractmethod
  def parse(self, command: str, args: List[str]) -> Entry:
    pass


class SinglePathParser(Parser):

  def parse(self, command: str, args: List[str]) -> Entry:
    self.check_supported(command)
    if len(args) != 1:
      raise ParserError(f'{command} supports only 1 argument, got {len(args)}')
    return self.parse_single_path(command, pathlib.Path(args[0]))

  @abc.abstractmethod
  def parse_single_path(self, command: str, path: pathlib.Path) -> Entry:
    pass


class SymlinkParser(SinglePathParser):

  @property
  def supported_commands(self) -> Container[str]:
    return ['symlink']

  def parse_single_path(self, command: str, path: pathlib.Path) -> Entry:
    del command  # unused
    return SymlinkEntry(self.root / path, self.prefix / path)


class CopyParser(SinglePathParser):

  @property
  def supported_commands(self) -> Container[str]:
    return ['copy']

  def parse_single_path(self, command: str, path: pathlib.Path) -> Entry:
    del command  # unused
    return CopyEntry(self.root / path, self.prefix / path)


class ManifestParser(SinglePathParser):

  @property
  def supported_commands(self) -> Container[str]:
    return ['subdir']

  def parse_single_path(self, command: str, path: pathlib.Path) -> Entry:
    del command  # unused
    return Manifest(self.root / path, self.prefix / path)


class Manifest(Entry):

  def __init__(self, root: pathlib.Path, prefix: pathlib.Path = pathlib.Path()):
    self._entries = []
    manifest_path = root / 'MANIFEST'
    self._register_parsers(
        ManifestParser(root=root, prefix=prefix),
        SymlinkParser(root=root, prefix=prefix),
        CopyParser(root=root, prefix=prefix),
    )
    with open(manifest_path) as f:
      for lineno, line in enumerate(f, 1):
        try:
          self._add_line(line)
        except ParserError as e:
          sys.exit(f'{manifest_path}:{lineno}: {e}')

  def _register_parsers(self, *parsers: Parser) -> None:
    self._parsers = dict()
    for parser in parsers:
      for command in parser.supported_commands:
        assert command not in self._parsers
        self._parsers[command] = parser

  def _add_line(self, line):
    if line.startswith('#'):
      return
    parts = shlex.split(line)
    if not parts:
      return
    if len(parts) == 0:
      return
    elif len(parts) == 1:
      self._add_command('symlink', parts)
    else:
      self._add_command(parts[0], parts[1:])

  def _add_command(self, command: str, args: List[str]) -> None:
    parser = self._parsers.get(command)
    if parser is None:
      raise ParserError(f'{command} is not supported by {type(self)}')
    self._entries.append(parser.parse(command, args))

  def __call__(self, db: InstalledDatabase) -> None:
    for entry in self._entries:
      entry(db)


class Installer:

  def __init__(self):
    self._old_db = InstalledDatabase.load_from(INSTALL)
    self._db = SyncInstalledDatabase(INSTALL)

  def uninstall(self):
    for link in reversed(self._old_db):
      if not link.is_symlink():
        log(f'Unable to remove {str(link)}')
        continue
      try:
        link.unlink()
        log(f'Removed symlink {str(link)}')
      except FileNotFoundError:
        # TODO missing_ok=True, python-3.8+
        pass
      for parent in link.parents:
        try:
          parent.rmdir()
          log(f'Removed empty directory {str(parent)}')
        except OSError:
          break
    try:
      INSTALL.unlink()
      # TODO missing_ok=True, python-3.8+
    except FileNotFoundError:
      pass

  def install(self):
    self._install(BASE)
    for overlay in sorted(OVERLAYS.iterdir()):
      if not overlay.is_dir():
        continue
      self._install(overlay)

  def _install(self, path):
    log(f'\nLoading {str(path)}')
    try:
      manifest = Manifest(path, pathlib.Path.home())
    except FileNotFoundError:
      log(f'No MANIFEST in {str(path)}')
      return
    manifest(self._db)


async def main():
  parser = argparse.ArgumentParser(description='Synchronized configuration setup')
  parser.add_argument('--no-update', '-d', action='store_false', dest='update')
  parser.add_argument('--uninstall', '-u', action='store_true', dest='uninstall_only')
  args = parser.parse_args()
  if args.update and not args.uninstall_only:
    if await update_all():
      log(f'Updated {str(SELF)}, restarting')
      os.execv(SELF, sys.argv + ['--no-update'])
  installer = Installer()
  installer.uninstall()
  if args.uninstall_only:
    sys.exit()
  installer.install()


if __name__ == '__main__':
  asyncio.run(main())
