use std::path::Path;

use crate::package::contents::lexer;

use super::args::Arguments;
use super::ast;

grammar(location: &Path);

pub Manifest: ast::Manifest = {
    <StatementList> => ast::Manifest {
        location: location.to_owned(),
        statements: <>,
    },
};

StatementList: Vec<ast::Statement> = {
    <mut list:StatementList> <st:Statement> => {
        list.push(st);
        list
    },
    <StatementList> EmptyLine,
    <Statement> => vec![<>],
    EmptyLine => Vec::new(),
};

EmptyLine = {
    LineTerminator,
};

Statement: ast::Statement = {
    <Invocation> LineTerminator => ast::Statement::Command(<>),
    <IfStatement> LineTerminator => ast::Statement::IfStatement(<>),
    <Assignment> LineTerminator => ast::Statement::Assignment(<>),
};

Invocation: ast::Invocation = {
    <start:@L>
    <name:Literal>
    <args:(<Literal>)*> => ast::Invocation {
        location: start,
        name,
        args: Arguments(args),
    },
};

IfStatement: ast::IfStatement = {
    <start:@L>
    <if_clause:IfClause>
    <else_if_clauses:ElseIfClause*>
    <else_statements:ElseClause?>
    => ast::IfStatement {
        location: start,
        if_clause,
        else_if_clauses,
        else_statements: else_statements.unwrap_or_default(),
    },
};

IfClause: ast::IfClause = {
    <start:@L>
    If
    <condition:Invocation>
    <statements:Block> => ast::IfClause {
        location: start,
        condition,
        statements,
    },
};

ElseIfClause = {
    Else <IfClause>,
};

ElseClause = {
    Else <Block>,
};

Block = {
    Begin
    <StatementList>
    End
};

Assignment: ast::Assignment = {
    <start:@L>
    <var:Literal>
    Assign
    <command:Invocation> => ast::Assignment {
        location: start,
        var,
        command,
    },
};

LineTerminator = {
    Newline,
    EndOfInput,
};

extern {
    type Location = lexer::Location;
    type Error = lexer::LocationError;

    enum lexer::Token {
        EndOfInput => lexer::Token::EndOfInput,
        Newline => lexer::Token::Newline,
        Literal => lexer::Token::Literal(<String>),
        If => lexer::Token::If,
        Else => lexer::Token::Else,
        Begin => lexer::Token::Begin,
        End => lexer::Token::End,
        Assign => lexer::Token::Assign,
    }
}
