use std::path::Path;

use crate::package::contents::lexer;

use super::ast;

grammar(location: &Path);

pub Manifest: ast::Manifest = {
    <StatementList> => ast::Manifest {
        location: location.to_owned(),
        statements: <>,
    },
};

StatementList: Vec<ast::Statement> = {
    <mut list:StatementList> <st:Statement> => {
        list.push(st);
        list
    },
    <StatementList> EmptyLine,
    <Statement> => vec![<>],
    EmptyLine => Vec::new(),
};

EmptyLine = {
    LineTerminator,
};

Statement: ast::Statement = {
    <Command> LineTerminator => ast::Statement::Command(<>),
    <IfStatement> LineTerminator => ast::Statement::IfStatement(<>),
};

Command: ast::Command = {
    <start:@L>
    <name:Literal>
    <args:(<Literal>)*> => ast::Command {
        location: start,
        name,
        args,
    },
};

IfStatement: ast::IfStatement = {
    <start:@L>
    If
    <conditional:Command>
    Begin
    <statements:StatementList>
    End => ast::IfStatement {
        location: start,
        conditional,
        statements,
    },
};

LineTerminator = {
    Newline,
    EndOfInput,
};

extern {
    type Location = lexer::Location;
    type Error = lexer::LocationError;

    enum lexer::Token {
        EndOfInput => lexer::Token::EndOfInput,
        Newline => lexer::Token::Newline,
        Literal => lexer::Token::Literal(<String>),
        If => lexer::Token::If,
        Begin => lexer::Token::Begin,
        End => lexer::Token::End,
    }
}
